Control Flow
============

---

Chapter 6

---

Control Flow
------------

Dictates the order of program execution

Unstructured Flow
-----------------

- Control flow is achieved using low-level constructs such as conditional branches and gotos
- Common in assembly languages and some other early languages

---

```fortran
if (A .lt. B) goto 10
...

10 ...
```

Structured Flow
---------------

- Gotos begin to be considered evil in the 60s
- We seek better tools to solve control flow problems
- Examples include `if`, `then`, `else` and `for`

Multi-level Returns
-------------------

- One "advantage" of goto is that it can jump anywhere in a program, not simply return to the caller
- Sometimes we want to jump outside of our immediate context, and multilevel returns can allow this

Exceptions
----------

- Exception handling is one example of a non-local return
- Execution moves from the point where the exception was raised to the point where the exception is handled

```python
def assert_positive(num):
  if num <= 0:
    raise ValueError

def assert_all_positive(nums):
  for n in nums:
    assert_positive(n)

try:
  assert_all_positive([1,2,3,-1])
except ValueError:
  print('All numbers are not positive')
```

Continuations
-------------

- Code address and referencing environment to be restored
- Captures the context in which execution can continue
- Normal continuation chain is the backtrace fo the runtime stack

First-class Continuations
-------------------------

- Certain programming languages allow continuations to be used directly and passed as parameters
- Languages include Scheme and Ruby

---

```ruby
require "continuation"

def foo(i, c)
  printf "start %d; ", i
  if i < 3 then foo(i+1, c) else c.call(i) end
  printf "end %d; ", i # Never called
end

v = callcc { |d| foo(1, d) }
printf "got %d;\n", v
```

Sequencing
----------

- Core to imperative programming
- Determines order of side effects such as assignment

Compound Statement
------------------

- An ordered list of statements that can be used where statements are expected
- Sometimes called *blocks*

Selection
---------

- Provide a way to select one set of statements based on a condition
- e.g. `if` or `switch`

Short-circuit Evaluation
------------------------

- Most modern languages will skip evaluating unneeded arguments in boolean expressions
- This creates more efficient programs
- This can be used for control flow

---

```js
function check_value(obj) {
  if (obj && obj.val) { // Confirms that obj is defined
    console.log('Value is set')
  } else {
    console.log('Value is unset')
  }
}

check_value()
check_value({'val':1})
```

Switch Statements
-----------------

- More efficient in hardware than nested conditionals
- Creates a jump table that moves executions in a single instruction

---

```c
#include <stdio.h>

void count_down(int n) {
  switch (n) {
    case 3:
      printf("Three\n");
    case 2:
      printf("Two\n");
    case 1:
      printf("One\n");
  }
}

int main(void) {
  count_down(3);
}
```

Iteration
---------

- Allows computers to perform the same task repeatedly
- Makes computers useful for more than fixed-size tasks
- Without some mechanism of iteration or recursion, run linearly coupled to program size

Enumeration-Controlled Loops
----------------------------

- Executed once for every value in a finite set
- e.g. `for` loop

---

```fortran
do i = 1, 10, 2
  ...
```

```c
for (int i = 1; i < 10; i+=2) {
  ...
```

```python
for i in range(1, 10, 2):
  ...
```

For loop code generation
------------------------

```
  mov first, r1
  mov step, r2
  mov last, r3
  goto check
body:
  # Loop body
  add r1, r2
check:
  cmp r1, r3
  jl body
```

Semantic Complications
----------------------

- Many languages e.g. C allow complex expressions in for loop control conditions
- Machine code for `for` loops must often be more complex, as loop count can't be easily predicted

Combination Loops
-----------------

Recursion
---------

Nondeterminacy
--------------
