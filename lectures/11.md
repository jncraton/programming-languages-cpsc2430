Control Abstraction
===================

---

Chapter 9

---

Abstraction
-----------

- Allows us to hide complexity behind simpler interfaces

Data Abstraction
----------------

- Create complex data structures with simple interfaces to pass around (e.g. records, structs, dictionaries, etc)

Control Abstaction
------------------

- Create organized sections of executable code that execute in well-understood ways and can be reused

Subroutine
----------

- Performs operations for the caller while the caller waits
- Arguments, or *actual parameters*, are passed to subroutines and mapped to *formal parameters* from the subroutine definition
- Subroutines that can return values can be called *functions*

Pass by Value
-------------

- Actual parameter values are made available to the subroutine
- Modification of values will not impact the caller
- This may involved making a copy in memory

Pass by Reference
-----------------

- Actual parameters are references to data from the caller
- Modifaction of values will impact caller
- Should not involve copying data

C
---

- Pass by value

---

```c
#include <stdio.h>

void increment(int* i) {
  // This will change the callers value
  *i = *i + 1;
}

int main(void) {
  int i = 0;
  increment(&i);
  printf("%d\n", i);
}
```

---

- If we want to be able to modify values, we need to pass values by reference
- We can't do this is C, but we can use pointers passed by value to emulate it

---

```c
#include <stdio.h>

void increment(int* i) {
  // This will change the callers value
  *i = *i + 1;
}

int main(void) {
  int i = 0;
  increment(&i);
  printf("%d\n", i);
}
```

---

If we allow C++, we can use a proper pass by reference mode.

```c++
#include <stdio.h>

void increment(int &i) {
  // This will change the callers value
  i = i + 1;
}

int main(void) {
  int i = 0;
  increment(i);
  printf("%d\n", i);
}
```

Python
------

- Pass by object reference
- Numbers and strings are passed by value
- Composite types such as objects are passed as a reference

---

```python
def increment(i):
  // Only modifies local value
  i = i + 1

i = 0
increment(i)
print(i)
```

---

Callers will be able to see modifications to mutable objects

---

```python
def append(mylist, value):
  mylist.append(value)

mylist = []
append(mylist, 1)
print(mylist)
```

Callers will still hold a reference to the exact same object

```python
def empty(mylist):
  # The caller won't be impacted by this reassignment
  mylist = []

mylist = [1,2]
empty(mylist)
print(mylist)
```

Immutable objects (such as tuples or strings) can't be modified for the caller

Call Stack
----------

- Memory space for functions to use to store local variables, return addresses, and other data
- Function calls push a new frame to the stack
- Returns pop their frame when they are finished with it

Call stack review resources
---------------------------

- [Short Video Lecture](https://www.youtube.com/watch?v=Q2sFmqvpBe0)
- [Wikipedia](https://en.wikipedia.org/wiki/Call_stack)

Parameter Passing
-----------------


