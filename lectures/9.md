Control Flow
============

---

Chapter 6

---

Control Flow
------------

Dictates the order of program execution

Unstructured Flow
-----------------

- Control flow is achieved using low-level constructs such as conditional branches and gotos
- Common in assembly languages and some other early languages

---

```fortran
if (A .lt. B) goto 10
...

10 ...
```

Structured Flow
---------------

- Gotos begin to be considered evil in the 60s
- We seek better tools to solve control flow problems
- Examples include `if`, `then`, `else` and `for`

Multi-level Returns
-------------------

- One "advantage" of goto is that it can jump anywhere in a program, not simply return to the caller
- Sometimes we want to jump outside of our immediate context, and multilevel returns can allow this

Exceptions
----------

- Exception handling is one example of a non-local return
- Execution moves from the point where the exception was raised to the point where the exception is handled

```python
def assert_positive(num):
  if num <= 0:
    raise ValueError

def assert_all_positive(nums):
  for n in nums:
    assert_positive(n)

try:
  assert_all_positive([1,2,3,-1])
except ValueError:
  print('All numbers are not positive')
```

Continuations
-------------

- Code address and referencing environment to be restored
- Captures the context in which execution can continue
- Normal continuation chain is the backtrace fo the runtime stack

First-class Continuations
-------------------------

- Certain programming languages allow continuations to be used directly and passed as parameters
- Languages include Scheme and Ruby

---

```ruby
require "continuation"

def foo(i, c)
  printf "start %d; ", i
  if i < 3 then foo(i+1, c) else c.call(i) end
  printf "end %d; ", i # Never called
end

v = callcc { |d| foo(1, d) }
printf "got %d;\n", v
```

Sequencing
----------

- Core to imperative programming
- Determines order of side effects such as assignment

Compound Statement
------------------

- An ordered list of statements that can be used where statements are expected
- Sometimes called *blocks*

Selection
---------

- Provide a way to select one set of statements based on a condition
- e.g. `if` or `switch`

Short-circuit Evaluation
------------------------

- Most modern languages will skip evaluating unneeded arguments in boolean expressions
- This creates more efficient programs
- This can be used for control flow

---

```js
function check_value(obj) {
  if (obj && obj.val) { // Confirms that obj is defined
    console.log('Value is set')
  } else {
    console.log('Value is unset')
  }
}

check_value()
check_value({'val':1})
```

Switch Statements
-----------------

Iteration
---------

Recursion
---------

Nondeterminacy
--------------
